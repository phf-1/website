#+ID: d1b5724d-434c-40a0-86e9-dfc81012ae43
#+TITLE: A simple actor definition
#+DATE: 2026-02-16
#+CITE_EXPORT: csl ieee.csl
#+LICENSE: https://creativecommons.org/licenses/by-nc-sa/4.0 CC-BY-NC-SA-4.0
#+STATUS: Draft

#+begin_abstract
This article offers a definition and construction methodology for the Actor Model to
provide a simple common vocabulary useful for software specification and
implementation.  Defining an actor implies defining a protocol (/what/ it does) and an
implementation (/how/ it does it). A stopwatch actor is provided as an illustrative
example.
#+end_abstract

* Introduction

Building correct software requires two distinct steps: writing a specification that
defines /what/ the system must do, and providing an implementation that tells the
computer /how/ to do it [cite:@lamport2002specifying]. An implementation ultimately
consists of instructions executable by a specific machine — the /kernel language/
[cite:@vanroy2004concepts].

Bridging this gap involves human programming, compilation, and increasingly, AI
assistance. Yet the industry lacks consensus on how to specify and program computers,
with little agreement even on notation [cite:@steele2017newold].

This fragmentation stems partly from evolving software requirements, especially the
need for coordination in massively concurrent systems. The Actor Model addresses this
by aligning with modern hardware properties while remaining expressive enough for
high-level specification [cite:@hewitt2010actormodel].

This work attempts to capture the essence of the Actor Model and provide a framework
for modeling software.

* Objective

- Provide a definition for an actor.
- Provide an illustrative example.
- Provide a method to build new actors.

* Context

The following resources were used:
- [[href:/4bdfa923-20d0-47bc-8d1e-d39d66d7c5e0/html][Writing by progressive refinements]]
- [[href:/32b32aa5-40cf-48c7-ac61-95e94eaa28a9/html][Type Theory]]
- Laws for communicating parallel processes [cite:@hewitt1977lawsA]
- Actor model of computation: Scalable robust information systems [cite:@hewitt2010actormodel]

* Machines

#+ID: 11a7296d-bf67-4894-94c9-66690c2fdf80
#+begin_definition
Computing today relies on a *network of heterogeneous machines*. Each of these machines
has its own memory, computation and communication capabilities. Some of them are
linked in some ways, /e.g./, TCP/IP or Email.
#+end_definition

* Actor system

#+ID: 889e352a-3ea6-4be5-bcf2-f6943ee37d16
#+begin_definition
An *actor system* is an abstraction used to model computing carried out by a network of
machines.
#+end_definition

Each actor is an abstraction representing some aspects of a machine. Communication
between machines is abstracted by giving actors the capability to send and receive
messages.

A message is the analogue of a letter: it has the address of an actor and an arbitrary
payload. After being sent, a message may or may not be received. Nothing guarantees
that a message will reach the designated actor. Even if it does, the actor may crash
before being able to send a reply, if any.

* Actor

#+ID: aae19666-8753-4527-8f7f-70d68533c58c
#+begin_definition
An actor is an abstract representation of a machine. It has a canonical address, a
state and a script:

#+begin_example
Actor :≡ Address × State × Script
#+end_example
#+end_definition

To build an actor, it is enough to provide an initial state, a script and have the
guarantee that there is a machine it is the abstraction of. Only the canonical
address is returned by the constructor as the only way to interact with an actor is
to send/receive messages to/from it. In other words:

#+ID: 6a19df71-959a-4387-9949-f2f26df9f075
#+begin_definition
#+begin_example
Actor#mk : Script State ⇝ Actor :≡
 script state ↦
  address :≡ Address#mk()
  actor :≡ <address, state, script>
  script is executing on some machine starting from state.
  For all messages of the form <address, _>,
    send(m) works as expected.
  address
#+end_example
#+end_definition

* Address

An actor has a canonical *address*.

#+ID: e74b3833-8f59-426a-a26f-1ad0b80d5650
#+begin_definition
An address is an abstract representation of whatever address the associated machine
may have, for instance an IP address or an email address in the sense that it can be
used to send data to the actor. In addition, an address cannot be arbitrarily
created, fabricated, guessed, or forged. The expression ~Address#mk()~ is the address
constructor.
#+end_definition

* State

An actor has a *state*.

#+ID: 5d74d0a1-2d29-4254-95d1-f961c1951ac2
#+begin_definition
A *state* is an instance of some type that acts as an abstract representation of the
associated machine's memory.
#+end_definition

* Script

An actor has a *script*.

#+ID: c796968d-171e-4393-a0af-2d22b0657f80
#+begin_definition
A *script* is an abstract representation of whatever programming language is used to
define the behaviour of its associated machine. It may use the following instructions:

- ■
- self
- send(m)
- receive()
- become(script [state])

In addition to the usual instruction set.
#+end_definition

The exact *Script* language is not specified here. We attempt to make our intent clear
using a pseudo-language even if formalisation attempts have been made, /e.g./, ActorScript
[cite:@hewitt:hal-01147821].

* ■

#+ID: 05a52904-d4ef-4887-b41e-6c4097145021
#+begin_definition
■ means that the current script stops, "killing" the current machine, /i.e./, freeing
all resources (/e.g./, CPU, Memory).
#+end_definition

* self

#+ID: de334c5b-21b8-45ec-88f4-1da5b467b001
#+begin_definition
*self* refers to the current canonical actor address.
#+end_definition

* Message

#+ID: 025ee834-c895-4aeb-92b8-3f8ff936b604
#+begin_definition
A message is the analogue of an envelope: it is formed by an actor address and an
arbitrary payload.

#+begin_example
Payload : Type
Message :≡ Address × Payload
#+end_example
#+end_definition

* send

#+ID: a8719a12-24f7-4153-83b8-301cf363621a
#+begin_definition
Given ~m : Message :≡ <address, payload>~, then send(m) means that the actor
represented by /address/ MAY receive /payload/. In other words:

#+begin_example
send(m) :≡
 <address, payload> ≡ m
 match actor(address)
  nothing ↦ ■
  just(actor) ↦ actor#rcv(payload)
#+end_example

#+begin_example
send(address payload) :≡ send(<address, payload>)
#+end_example
#+end_definition

/actor(address) ≡ just(actor)/ is an abstract way to say that the message reached the
actor associated with /address/ thanks to whatever underlying networking technology was
used, /e.g./, TCP/IP.

/actor#rcv(payload)/ means that /payload/ has been written to the I/O subsystem of
/machine(actor)/ so that when /actor/ executes /receive/, then it can pattern match against
/payload/.

/just(actor) ↦ actor#rcv(payload)/ means that if the message reaches /actor/, then the
actor can pattern match against the payload. In other words, we abstract away what
could prevent /actor/ from pattern matching against /payload/, /e.g./, size limits of the I/O
subsystem.

/send/ does not return anything, so we consider this instruction /asynchronous/, /i.e./, it
does not block.

* receive

#+ID: 971a5148-6d66-4ef6-a980-f9486b62090f
#+begin_definition
*receive* is a language construct that allows the current actor to pattern match against
message payloads not already processed.

If a payload ~p~ triggers the execution of one of the receive branches, /i.e./, ~<cond(p),
script>~, then /script/ is executed; else /receive/ blocks until a new message is
received. (TODO timeout).
#+end_definition

For instance:

#+ID: 61dfb1c8-2154-4dcf-a284-4f26dfa49606
#+begin_example
receive
  <from, n> when n > 0 ↦ send(from "${n} > 0")
  "stop" ↦ ■
#+end_example

means that if a message /m/ is of the form <from, n> where n > 0, then a string is
replied to the sender. If ~"stop"~ is received, then the actor dies.

* become

#+ID: abfd4a0c-98c9-4248-9015-a50a48e8bc6e
#+begin_definition
Given /script : Script/, then after *become(state script)*, the current actor executes /script/ from /state/.
#+end_definition

For instance:

#+ID: fa1f71b0-4e37-4aa3-ba29-df3dce387e34
#+begin_example
french :≡
  receive
    <from, "hello"> ↦ send(from "Bonjour")
  become(french)

italian :≡
  receive
    <from, "hello"> ↦ send(from "Buongiorno")
  become(italian)

receive
  "french" ↦ become(french)
  "italian" ↦ become(italian)
#+end_example

The previous example means that the current actor will reply "Bonjour" to "hello"
after receiving "french" and "Buongiorno" after receiving "italian".

* Example

In order to use the previous definitions, let's define a stopwatch using the actor
model.

** Oscillator

We model an [[https://en.wikipedia.org/wiki/Electronic_oscillator][oscillator]] by an actor built using the expression:
~Oscillator#mk()~. We assume that the definition of this expression is given. It acts
as a black box; we only know the protocol it is supposed to fulfil, namely:

#+begin_quote
~oscillator :≡ Oscillator#mk()~ is an oscillator that starts emitting ticks every
second starting as soon as it is created.

Given an actor ~α~, then ~oscillator#subscribe(α)~ will subscribe ~α~ to the ticks of
~oscillator~. It means that ~α~ will receive a message ~<oscillator, "tick">~ after each
emission.

~oscillator#unsubscribe(α)~ is the reciprocal operation.
#+end_quote

** Stopwatch

Since the definition of a stopwatch is not given, we provide it ourselves. First, we describe the protocol, in other words *what it does*:

#+begin_quote
A stopwatch is an actor that implements the following protocol: it starts counting
elapsed seconds as soon as it is created. Then, it replies ~<stopwatch, seconds>~ to a
message ~<actor, "read">~. ~seconds : ℕ~ and ~actor~ is an actor address.
#+end_quote

Now, we can define *how it does it* by defining a constructor. To build an actor, we
need to define a state and a script. So, we define a constructor ~Stopwatch#mk()~ that builds
an actor that implements the desired behaviour as follows:

#+begin_example
script :≡
 n : Nat ↦
  seconds :≡ n
  oscillator :≡ Oscillator#mk()
  oscillator#subscribe(self)
  next :≡
   seconds ↦
    receive
     <oscillator, "tick"> ↦
      become(next seconds+1)

     <actor, "read"> ↦
      send(actor <self, seconds>)
      become(next seconds)
  next(seconds)

Stopwatch#mk() :≡ Actor#mk(script 0)
#+end_example

** Usage

So, an actor executing the following script:

#+begin_example
stopwatch :≡ Stopwatch#mk()
send(stopwatch <self, "read">)
receive
  <stopwatch, sec> ↦ "#{sec} seconds elapsed."
#+end_example

would start a stopwatch then ask the stopwatch for the number of elapsed seconds.

* Protocol

#+ID: 9feaaec8-09ba-479d-abc0-b132a0a17a91
#+begin_definition
A *protocol* describes message sequences and expected replies.
#+end_definition

TODO: look at session types.

* Actor construction

As seen in the example, defining an actor starts with /what/ it should do. This
definition takes the form of a protocol it must implement. Then, a constructor for
that type of actor must be defined. It defines /how/ the actor implements its
protocol. The /how/ is certainly better expressed using an executable programming
language instead of a pseudo-language. A higher-level language seems to be necessary
to express the /what/ in any meaningful manner.

* Result

An actor definition has been provided together with a method to define different
kinds of actors. An illustrative example has been provided in the form of a stopwatch
actor.

* TODO Discussion

* TODO Conclusion

* Bibliography

#+print_bibliography:

* Local Variables                                                  :noexport:

Local Variables:
eval: (add-hook 'before-save-hook #'whitespace-cleanup nil t)
eval: (add-hook 'after-save-hook #'user--org-export-current-buffer-to-utf8-buffer nil t)
org-confirm-babel-evaluate: nil
fill-column: 85
End:
