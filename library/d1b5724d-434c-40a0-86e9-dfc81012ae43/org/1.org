#+ID: d1b5724d-434c-40a0-86e9-dfc81012ae43
#+TITLE: A simple actor definition
#+DATE: 2026-02-07
#+CITE_EXPORT: csl
#+LICENSE: https://creativecommons.org/licenses/by-nc-sa/4.0 CC-BY-NC-SA-4.0
#+STATUS: Draft

#+begin_abstract
TODO
#+end_abstract

* Introduction

In 1986, Gul Agha wrote: /It is generally believed that the next generation of
computers will involve massively parallel architectures [cite:@agha1986actors]./
Today, in 2026, 40 years later, it is the case. The central abstraction to deal with
this fact is the idea of an /Actor/. We go through available published work and attempt
to provide a simple definition to this idea, then a few examples and finally use
cases.

* Objective

- Define what an /actor/ is.
- Provide an illustrative example.
- Provide a use case.

* Type Theory
** :‚â°

#+ID: 9bfb7073-0f1f-4d3d-a6f2-3fb591502de6
#+begin_definition
*:‚â°* :‚â° üûé
#+end_definition

** Type

#+ID: 020fad82-9d00-4543-926d-832c91442f99
#+begin_definition
*Type* :‚â° üûé
#+end_definition

** X ‚Üí Y

#+ID: 2cd5a5e7-8e7f-4bd3-8883-ea557bff0fd7
#+begin_definition
*X ‚Üí Y* :‚â° üûé
#+end_definition

** X √ó Y

#+ID: 6e00b58e-0ffb-4e6a-af80-26ce98049025
#+begin_definition
*X √ó Y* :‚â° üûé
#+end_definition

** X | Y

#+ID: 2904f563-4b22-46ca-b294-90df524f7163
#+begin_definition
*X | Y* :‚â° üûé
#+end_definition

** Nat

#+ID: 6e6069cd-adf1-4f69-a95d-abfed657fd3d
#+begin_definition
*Nat* :‚â° üûé
#+end_definition

** String

#+ID: 5702b0b7-a4bd-4933-bc07-0f30b0f85899
#+begin_definition
*String* :‚â° List(Nat)
#+end_definition

** List

#+ID: 688dbc9a-9f1f-471f-b362-5703765684c5
#+begin_definition
*List* :‚â° üûé
#+end_definition

** Just

#+ID: a6d97a04-6512-4c0b-b4ee-011afac18074
#+begin_definition
- X : Type
- *Just(X)* :‚â° üûé
#+end_definition

** Nothing

#+ID: 4a47e9a0-8d54-456f-9863-ceecde5b36a8
#+begin_definition
*Nothing* :‚â° üûé
#+end_definition

** Maybe

#+ID: a489781c-9a92-4c11-9698-81750460e9cf
#+begin_definition
- X : Type
- *Maybe(X)* :‚â° Nothing | Just(X)
#+end_definition

** StrictPartialOrder

#+ID: 6086ccfe-0154-4590-b38d-fb994fa0a137
#+begin_definition
*StrictPartialOrder(X)* :‚â° üûé
#+end_definition

** Set

#+ID: 6c127151-52d8-4f16-9f8e-9ce43f34b353
#+begin_definition
- X : Type
- = : X X ‚Üí Boolean
- = is an equality
- *Set(X =)* :‚â°
  - list : List(X)
  - e(i) ‚àà list, e(j) ‚àà list, i ‚â† j, e(i) ‚â† e(j)
#+end_definition

* Gul A. Agha 1986
:PROPERTIES:
:ID:       2135593c-cfaa-4c41-8c41-6966295cf3aa
:END:

/Actors: A Model of Concurrent Computation in Distributed Systems/
[cite:@agha1986actors], seems to be the main book about actors. Unfortunately, I find
it hard to understand.

* Hewitt 2010
:PROPERTIES:
:ID:       451cdbd4-55e6-4787-8b35-56c0d7d6c561
:END:

Time may have sorted out a clearer exposition in /Actor Model of Computation: Scalable
Robust Information Systems/ [cite:@hewitt2010actormodel].

#+begin_quote
Message passing using types is the foundation of system communication:
- Messages are the unit of communication1
- Types enable secure communication with any Actor
#+end_quote

What is the definition of a Message? What is the definition of an Actor?

#+begin_quote
When an Actor receives a message, it can concurrently:
- send messages to (unforgeable) addresses of Actors that it has;
- create new Actors;
- designate how to handle the next message it receives.
#+end_quote

What is an address?

#+begin_quote
It is a consequence of the Actor Model that there are some computations that cannot
be implemented in the lambda calculus.
#+end_quote

Proof?

#+begin_quote
The Actor Model is a mathematical theory of computation that treats ‚ÄúActors‚Äù as the
universal primitives of concurrent digital computation [Hewitt, Bishop, and Steiger
1973; Hewitt 1977]
#+end_quote

So, this is where we should look for the definition of an Actor.

#+begin_quote
The advent of massive concurrency through client-cloud computing and many-core
computer architectures has galvanized interest in the Actor Model [Hewitt 2009b].
#+end_quote

It took a few decades, but time seems to favor the actor model. /Hewitt 2009b/ should
explain why.

#+begin_quote
An Actor can only communicate with another Actor to which it has an address.
Addresses can be implemented in a variety of ways:
- direct physical attachment
- memory or disk addresses
- network addresses
- email addresses
#+end_quote

But why not just give definitions like mathematicians do? Just a sequence of
consistent definitions and propositions, maybe with proofs.

#+begin_quote
The Actor Model is characterized by inherent concurrency of computation within and
among Actors, dynamic creation of Actors, inclusion of Actor addresses in messages,
and interaction only through direct asynchronous message passing with no restriction
on message reception order.
#+end_quote

/direct asynchronous message passing/?

#+begin_quote
The Actor Model differs from its predecessors and most current models of
computation in that the Actor Model assumes the following:
- Concurrent execution in processing a message.
- The following are not required by an Actor: a thread, a mailbox, a
message queue, its own operating system process, etc.
- Message passing has the same overhead as looping and procedure
calling.
- Primitive Actors can be implemented in hardware.
#+end_quote

Ok.

#+begin_quote
The Actor Model is based on one-way asynchronous communication. Once a message has
been sent, it is the responsibility of the receiver. Messages in the Actor Model are
decoupled from the sender and are delivered by the system on a best efforts
basis. [‚Ä¶] message passing is taken as fundamental in the Actor Model. [‚Ä¶] laws for
Actors [Baker and Hewitt 1977]
#+end_quote

Fine.

#+begin_quote
The Actor Model supports indeterminacy because the reception order of messages can
affect future behavior.  Operations are said to be quasi-commutative to the extent
that it doesn‚Äôt matter in which order they occur. To the extent possible,
quasi-commutativity is used to reduce indeterminacy.
#+end_quote

Does this have any relationship with eventual consistency?

#+begin_quote
Locality and security mean that in processing a message: an Actor can send
messages only to addresses for which it has information by the following
means:
1. that it receives in the message
2. that it already had before it received the message
3. that it creates while processing the message.
#+end_quote

/One of the things that every sorcerer will tell you is that if you have the name of
the spirit, you have power over it./ [cite:@sussman1986lecture1b].

#+begin_quote
In the Actor Model, there is no hypothesis of simultaneous change in multiple
locations. In this way it differs from some other models of concurrency.
#+end_quote

non-local effects are rejected. /I cannot seriously believe in it [quantum mechanics]
because the theory is incompatible with the principle that physics should represent a
reality in time and space, free from spooky actions at a distance./
[cite:@einstein1947letter].

#+begin_quote
The security of Actors can be protected in the following ways:
- hardwiring in which Actors are physically connected
- every-word-tagged memory.
- virtual machines as in Java virtual machine, Common Language
Runtime, etc.
- signing and/or encryption of Actors and their addresses
A delicate point in the Actor Model is the ability to synthesize the address of
an Actor. In some cases security can be used to prevent the synthesis of
addresses in practice using the following:
- every-word-tagged memory
- signing and encryption of messages
#+end_quote

Interesting.

#+begin_quote
Runtime failures are always a possibility in Actor systems and are dealt with by
runtime infrastructures. Message acknowledgement, reception, and response cannot be
guaranteed although best efforts are made. Consequences are cleaned up on a
best-effort basis.  Robustness is based on the following principle: If an Actor is
sent a request, then the continuation will be one of the following two mutually
exclusive possibilities:
1. to respond with the response received from the Actor sent the request
2. to throw a Messaging exception

A response is either a returned value or a thrown exception. A Messaging exception
can have information concerning the lack of response. even though the Actor may have
received the request and sent a response that has not yet been received. Requestors
need to be able to interact with infrastructures concerning policies to be applied
concerning when to generate Unresponsive exceptions.
#+end_quote

Ok, so we know what to expect when "speaking" with an actor.

#+begin_quote
The Computational Representation Theorem [Clinger 1981; Hewitt 2006]11 characterizes
computation for systems which are closed in the sense that they do not receive
communications from outside. [‚Ä¶] The upshot is that concurrent systems can be
axiomatized using mathematical logiciv but in general cannot be implemented. Thus,
the following practical problem arose:

"How can practical programming languages be rigorously defined since the proposal by
Scott and Strachey [1971] to define them in terms lambda calculus failed because the
lambda calculus cannot implement concurrency?"
#+end_quote

Does it have any implication in practice? See Plotkin "or" and the fact that lambda
calculous it can simulate some parallelism (via Church-Rosser allowing independent
reductions), but not true non-deterministic or fair concurrency where independent
subcomputations can converge independently without full
evaluation. [cite:@plotkin1977lcf]

#+begin_quote
Programming languages like ActorScript [Hewitt 2010] take the approach of extending
behavior in contrast to the approach of specializing behavior:

- Type specialization: If type t1 is a subtype of type t2, then instances of t1 have
  all of the properties that are provable from the definition of type t2 [Liskov
  1987, Liskov and Wing 2001].

- Type extension: A type can be extended to have additional (perhaps incompatible)
  properties from the type that it extends. An extension type can make use of the
  implementation of the type that it extends.  Type extension is commonly used to
  extend operating system software as well as applications.

The term ‚Äúinheritance‚Äù in programming has been used (sometimes ambiguously) to mean
both specialization and extension.
#+end_quote

Interesting distinction: Specializing and Extension.

#+begin_quote
Reasoning about Actor Systems
The principle of Actor induction is:
1. Suppose that an Actor x has property P when it is created
2. Further suppose that if x has property P when it receives a message,
then it has property P when it receives the next message.
3. Then x always has the property P.
In his doctoral dissertation, Aki Yonezawa developed further techniques for
proving properties of Actor systems including those that make use of migration.
Russ Atkinson developed techniques for proving properties of Actors that are
guardians of shared resources. Gerry Barber's 1981 doctoral dissertation
concerned reasoning about change in knowledgeable office systems.
#+end_quote

So reasoning, /i.e./ deriving conclusions from premises, is possible.

#+begin_quote
- Swiss cheese [Hewitt and Atkinson 1977, 1979; Atkinson 1980].
- Futures [Baker and Hewitt 1977].
#+end_quote

Time is scarce, let us focus and skip things.

* TODO Hewitt & Baker 1977

[cite:@hewitt1977lawsA]

** Bit

#+ID: 24c3453b-bb18-4847-b842-ddaaeb979fb7
#+begin_definition
*Bit* :‚â° 0 | 1
#+end_definition

** Data

#+ID: bff3df2b-ce8e-44c1-a64e-526e2080a483
#+begin_definition
*Data* :‚â° List(Bit)
#+end_definition

** State

#+ID: a165ae1c-d951-4022-a3bf-c34949ffd78a
#+begin_definition
*State* :‚â° Data
#+end_definition

** Address

#+ID: 51467de6-4263-4e6a-bda1-c87576cf3dff
#+begin_definition
*Address#mk()* : Address :‚â° Data such that it cannot be arbitrarily created,
fabricated, guessed, or forged by any actor in the system.
#+end_definition

** Message

#+ID: b9348b43-b317-4313-830f-6d218274c3e7
#+begin_definition
*Message* :‚â° Data
#+end_definition

** Script

#+ID: 77527c87-3faa-43f5-8cd4-0d49729d19c7
#+begin_definition
*Script* :‚â° Given /state : State/ and /script : Script/, then /script(state)/ is a program
starting from /state/ executing what is prescribed by /script/ with the only restriction
that its I/O is done by sending and receiving messages.

The precise meanings of /sending/ and /receiving/ are left to interpretation as well as
the precise instructions set executed by the program or how they are prescribed by
/script/.
#+end_definition

** ‚ñ†

#+ID: 05a52904-d4ef-4887-b41e-6c4097145021
#+begin_definition
*‚ñ†* :‚â° Withing a script, ‚ñ† means that the current script stops equivalent to ~return~ in
 C.
#+end_definition

** receive

#+ID: c20369ab-2da7-453a-8b62-f9956c8bdf21
#+begin_definition
*receive([timeout : Nat])* :‚â° whenever a message /msg/ has been received by a program I/O
subsystem, then /receive([timeout])/ is to be replaced by /msg/. This instruction blocks
until then. If /timeout/ is specified, and no message is received before the timeout is
exhausted, then /receive(timeout)/ is to be replaced by an instance of Timeout ; a kind
of message.
#+end_definition

** emit

#+ID: 061b53ce-b7a4-4b77-852b-b2bc601efc17
#+begin_definition
*emit(msg)* :‚â° Within a script, given a message /msg/, /emit(msg)/ means that any actor
 observing the current observer will receive /msg/.
#+end_definition

** self

#+ID: de334c5b-21b8-45ec-88f4-1da5b467b001
#+begin_definition
*self* :‚â° Within /script : Script/, then /self/ refers to the current actor actor.
#+end_definition

** ‚à•

#+ID: 961861bf-bba5-4fc9-ac63-0812d15d38bd
#+begin_definition
*‚à•* :‚â° Given /state : State/ and /script : Script/, then /‚à•(state script)/ means that
resources are allocated (/e.g./ CPU, Memory, energy) so that a program executing /script/
and starting from /state/ is created. /program :‚â° ‚à•(state script)/ means that /program/
references the created program. Does not block.
#+end_definition

** Actor

#+ID: 64945c67-bdfa-41bb-bf1d-4608f0351a9a
#+begin_definition
- state : State
- script : Script
- *Actor#mk(state script)* : Actor :‚â°
  - self :‚â° Address#mk()
  - program :‚â° ‚à•(state script)
  - Given /msg : Message/, then after /self#rcv(msg)/, /program/ has received /msg/.
  - self
#+end_definition

** observe and ignore

#+ID: ff689b57-13a2-43ac-bad4-132387c8eb1e
#+begin_definition
*observe(actor)* :‚â° Given /actor : Actor/, then after executing /observe(actor)/,
any message emitted on the I/O subsystem of the underlying actor is received by the
current program. This instruction does not block.
#+end_definition

#+ID: 5f18fa31-a763-4049-bb70-5f0fd905811d
#+begin_definition
*ignore(actor)* :‚â° Reciprocal of /observe(actor)/.
#+end_definition

** Clock

Let's attempt to model a clock using Actor. We assume the existance of /crystal :
Address/ such that the underlying actor emits instances of /Tick/ ‚Äî a kind of Message ‚Äî
on its I/O subsystem.

Note that the instructions executing order is not given by the script ; only some
constraints are. For instance, ~a :‚â° A#mk(‚Ä¶); b :‚â° f(a)~ imposes and order, but ~a :‚â°
A#mk(‚Ä¶); b :‚â° B#mk(‚Ä¶)~ does not.

Note that the following script must be understood as being executed by an actor.

#+begin_example
decode : Message ‚Üí (String √ó Address) | String | Nothing

script :‚â°
  <n : Nat, crystal : Crystal> ‚Ü¶
    time :‚â° n
    observe(crystal)
    while msg :‚â° receive()
      match decode(msg)
        <"tick", crystal> ‚Ü¶ time :‚â° time + 1
        <"read", to : Address> ‚Ü¶ to#rcv(<time, self>)
        "stop" ‚Ü¶ ‚ñ†

state :‚â° <0, crystal>

clock :‚â° Actor#mk(state script)

clock#rcv(<"read", self>)

while msg :‚â° receive()
  match msg
    <time : Nat, clock> ‚Ü¶
      "The time is: ${time}"
      ‚ñ†
    _ ‚Ü¶ continue
#+end_example

** Events

#+ID: 0a22ef9e-8412-4b40-8b0f-07cb8c36a041
#+begin_definition
*Events* :‚â° Set(Event List=)
#+end_definition

** Discretness

#+ID: 8cfe2ab7-813b-427b-b440-0b30c29e4a65
#+begin_definition
- E : Events
- < : StrictPartialOrder(E)
- *Discretness(E <)* :‚â° üûé
#+end_definition

** concurrent with

#+ID: 8a583e0a-98d9-4492-bceb-a1bbbd670eee
#+begin_definition
- E : Events
- e(i), e(j) ‚àà E
- < : StrictPartialOrder(E)
- *e1 concurrent with e2* :‚â° üûé
#+end_definition

** precedes

#+ID: 8a583e0a-98d9-4492-bceb-a1bbbd670eee
#+begin_definition
- E : Events
- e(i), e(j) ‚àà E
- < : StrictPartialOrder(E)
- *e1 precedes e2* :‚â° üûé
#+end_definition

** message

#+ID: 282b8ce7-b630-4acd-a6e2-860c3a51f985
#+begin_definition
*message* : Event ‚Üí Message
#+end_definition

** ActorComputation

#+ID: fc87fe10-230f-43fc-97d4-0660a2f99207
#+begin_definition
- *ActorComputation* :‚â°
  - E : Events
  - < : StrictPartialOrder(E)
  - Discretness(E <)
#+end_definition

** Event

#+ID: c1eadb3d-a5e5-4e44-a80f-54f7b93db576
#+begin_definition
*Event* :‚â° Data
#+end_definition

* TODO Hewitt 1977

[cite:@hewitt1977viewing]

* Message definition

#+ID: 6dc94cfa-c366-4082-898b-208923ac958b
#+begin_definition
A message is an immutable parcel of data sent to an actor‚Äôs address. It contains at
minimum the recipient address and whatever information the sender chooses to
communicate.
#+end_definition

* Actor definition

#+ID: c5b69743-a729-45ec-a95f-f91aeae0d0a5
#+begin_definition
An /actor/ is an independent computational entity with three essential properties:

1. It has /addresses/.
2. It has private internal state.
3. When it receives a /message/ at its address, it may do the following concurrently:
   - send messages to addresses it knows,
   - create new actors,
   - change how it will react to the next message.

Messages are one-way and asynchronous: once sent, the sender cannot wait for or
assume delivery.
#+end_definition

* TODO Example

* TODO Use case

* TODO Result

* TODO Discussion

* TODO Conclusion

* TODO Bibliography

#+print_bibliography:
